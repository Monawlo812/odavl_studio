[{"filePath":"C:\\Users\\sabou\\odavl_studio\\$OUT\\extract-vscode.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\.odavl\\eslint-immune.cjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\apps\\cli\\bin\\odavl.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\apps\\launcher\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\apps\\orchestrator\\__tests__\\scheduler.spec.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: \"parserOptions.project\" has been provided for @typescript-eslint/parser.\nThe file was not found in any of the provided project(s): apps\\orchestrator\\__tests__\\scheduler.spec.ts"}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect } from 'vitest';\nimport { scheduleWorkflows } from '../src/index.js';\n\ndescribe('scheduler', () => {\n  it('schedules up to maxConcurrency', async () => {\n    const repos = [\n      { name: 'repo1', prPerDay: 2, ciMinutesPerHour: 10 },\n      { name: 'repo2', prPerDay: 1, ciMinutesPerHour: 5 }\n    ];\n    const running = await scheduleWorkflows(repos, 1);\n    expect(running).toBeLessThanOrEqual(1);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\apps\\orchestrator\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\apps\\orchestrator\\src\\scheduler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\apps\\vscode-ext\\scripts\\validate-icon.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\examples\\golden-repo\\eslint.config.cjs","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: 'import' and 'export' may appear only with 'sourceType: module'","line":1,"column":1}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import js from \"@eslint/js\";\nimport jest from \"eslint-plugin-jest\";\n\n/**\n * ESLint 9+ flat config for ESM, Jest, and ignore patterns.\n * - Enables recommended JS rules\n * - Enables Jest plugin and globals for test files\n * - Ignores build, node_modules, and dist\n */\nexport default [\n  js.configs.recommended,\n  {\n    files: [\n      \"**/*.test.ts\",\n      \"**/*.test.js\",\n      \"**/__tests__/**/*.ts\",\n      \"**/__tests__/**/*.js\",\n    ],\n    plugins: { jest },\n    languageOptions: {\n      globals: jest.environments.env.globals,\n    },\n    rules: {\n      ...jest.configs.recommended.rules,\n    },\n  },\n  {\n    ignores: [\n      \"node_modules/\",\n      \"dist/\",\n      \"build/\",\n      \"coverage/\",\n      \"*.d.ts\",\n      \"*.js\",\n      \"*.cjs\",\n      \"*.mjs\",\n      \"*.json\",\n      \"*.md\",\n      \"out/\",\n      \"reports/\",\n    ],\n  },\n];\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\examples\\golden-repo\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\@types\\odavl__policy.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\__tests__\\redaction.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\@types\\odavl__policy.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token module","line":1,"column":9}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare module '@odavl/policy' {\n  // Minimal stub for TypeScript\n  export function enforceRbac(action: any, role: any): boolean;\n  export type RbacRole = string;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\commands\\demo.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\commands\\metrics.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":9,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":12,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CLI: odavl metrics serve\nimport { serveMetrics } from '../lib/metrics.js';\n\nexport function metricsServe() {\n  try {\n    serveMetrics();\n  } catch (err) {\n    const msg = err instanceof Error ? err.message : String(err);\n    console.error(\n      `Metrics server failed to start: ${msg}. Ensure prom-client and express are installed.`\n    );\n    process.exit(1);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\commands\\policy-org.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":8,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":8,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":10,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":10,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":13,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":13,"endColumn":12}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CLI: odavl policy validate --org\nimport { validateOrgPolicy } from '../policy-bridge.js';\n// @ts-ignore\nexport function runOrgPolicyValidate(repoPolicies) {\n  const result = validateOrgPolicy(repoPolicies);\n  if (!result.ok) {\n    // @ts-ignore\n    console.error('Org policy validation failed:', result.errors);\n    // @ts-ignore\n    process.exit(1);\n  } else {\n    // @ts-ignore\n    console.log('Org policy validation passed.');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\commands\\pricing.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":5,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":9,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":9,"endColumn":12}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CLI: odavl pricing show\nimport * as fs from 'fs';\nimport * as path from 'path';\nexport function showPricing() {\n  const root = process.cwd();\n  const file = path.join(root, 'config', 'pricing.json');\n  const data = JSON.parse(fs.readFileSync(file, 'utf8'));\n  for (const tier of data.tiers) {\n    console.log(`\\n${tier.name}\\nFeatures: ${tier.features.join(', ')}\\nLimits: ${JSON.stringify(tier.limits)}\\nSLA: ${tier.sla}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\index.ts","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":30,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Main CLI entrypoint for ODAVL\nimport { showPricing } from './commands/pricing.js';\nimport { runOrgPolicyValidate } from './commands/policy-org.js';\nimport { metricsServe } from './commands/metrics.js';\nimport { runDemo } from './commands/demo.js';\nimport { Command } from 'commander';\n\nconst program = new Command();\n\nprogram\n  .command('pricing show')\n  .description('Show pricing tiers')\n  .action(showPricing);\n\nprogram\n  .command('policy validate --org')\n  .description('Validate organization policy')\n  .action(runOrgPolicyValidate);\n\nprogram\n  .command('metrics serve')\n  .description('Serve Prometheus metrics')\n  .action(metricsServe);\n\nprogram\n  .command('demo')\n  .description('Run demo smoke on examples/demo')\n  .action(runDemo);\n\nprogram.parse(process.argv);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\lib\\audit.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":3,"column":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Audit logger stub with redaction\nimport { redact } from './redaction.js';\nexport function logAudit(entry: string) {\n  // In real use, append to audit log file\n  process.stdout.write(redact(entry));\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\lib\\cosign.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":4,"column":36}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Cosign availability stub for attestation signing\nimport { execSync } from 'child_process';\n\nexport function isCosignAvailable(): boolean {\n  try {\n    execSync('cosign version', { stdio: 'ignore' });\n    return true;\n  } catch {\n    return false; // fallback: cosign not found\n  }\n}\n\n// Future: add sign/verify helpers here\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\lib\\logging.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":2,"column":28}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Structured JSON logging for ODAVL CLI\nexport function logJson(obj: Record<string, unknown>) {\n  process.stdout.write(JSON.stringify(obj) + '\\n');\n}\n\nexport function logWithCorrelation(msg: string, correlationId?: string, verbose?: boolean) {\n  if (verbose && correlationId) {\n    logJson({ msg, correlationId, ts: new Date().toISOString() });\n  } else {\n    console.log(msg);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\lib\\metrics.ts","messages":[],"suppressedMessages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":23,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":23,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\lib\\rbac.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":3,"column":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CLI/extension RBAC check stub\nimport { enforceRbac } from '@odavl/policy';\nexport function checkRbac(action: string, role: string) {\n  if (!enforceRbac(action as any, role as any)) {\n    console.warn(`[RBAC] Action '${action}' denied for role '${role}'.`);\n    // In next batch, this will throw or exit\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\lib\\redaction.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":9,"column":27}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Secrets redaction utility\nexport const REDACT_PATTERNS = [\n  /AKIA[0-9A-Z]{16}/g,                 // AWS\n  /xox[baprs]-[0-9A-Za-z-]+/g,         // Slack\n  /ghp_[A-Za-z0-9]{36}/g,              // GitHub\n  /(?:secret|token|apikey)=\\S+/gi      // generic\n];\n\nexport function redact(str: string): string {\n  let result = str;\n  for (const pat of REDACT_PATTERNS) {\n    result = result.replace(pat, '***REDACTED***');\n  }\n  return result;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\cli\\src\\policy-bridge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\__tests__\\esmHygiene.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\axios-to-fetch.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":7,"column":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from \"fs\";\nimport path from \"path\";\n\nconst GUARDS = { maxFiles: 10, maxLines: 40 };\nconst RE_AXIOS = /\\baxios\\.(get|post|put|delete)\\s*\\(/g;\n\nfunction walk(dir: string, exts = [\".js\", \".ts\"], out: string[] = []) {\n  for (const f of fs.readdirSync(dir)) {\n    if (f === \"node_modules\" || f.startsWith(\".\")) continue;\n    const p = path.join(dir, f);\n    const stat = fs.statSync(p);\n    if (stat.isDirectory()) walk(p, exts, out);\n    else if (stat.isFile() && exts.some((e) => f.endsWith(e))) out.push(p);\n  }\n  return out;\n}\n\nexport function axiosToFetchDryRun({\n  root = process.cwd(),\n  dryRun = true,\n  maxFiles = GUARDS.maxFiles,\n  maxLines = GUARDS.maxLines,\n} = {}) {\n  const files = walk(root);\n  let candidates: { file: string; line: number; call: string }[] = [];\n  for (const file of files) {\n    const src = fs.readFileSync(file, \"utf8\");\n    let m;\n    let lines = src.split(/\\r?\\n/);\n    let seen = new Set();\n    while ((m = RE_AXIOS.exec(src))) {\n      // Approximate line number\n      const idx = src.slice(0, m.index).split(/\\r?\\n/).length;\n      const call = `axios.${m[1]}`;\n      const key = `${file}:${idx}:${call}`;\n      if (!seen.has(key)) {\n        candidates.push({ file, line: idx, call });\n        seen.add(key);\n      }\n    }\n  }\n  const filesTouched = new Set(candidates.map((c) => c.file)).size;\n  const linesTouched = candidates.length;\n  const guardHit = filesTouched > maxFiles || linesTouched > maxLines;\n  return {\n    recipe: \"axios-to-fetch\",\n    dryRun: true,\n    candidates,\n    changes: { files: filesTouched, lines: linesTouched },\n    guards: { maxFiles, maxLines, guardHit },\n    note: \"dry-run only, no modifications applied\",\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\py-requests-to-httpx.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":17,"column":18}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from \"fs\";\nimport path from \"path\";\n\nconst GUARDS = { maxFiles: 10, maxLines: 40 };\nconst RE_IMPORT = /^\\s*import\\s+requests\\b/m;\nconst RE_FROM_IMPORT = /^\\s*from\\s+requests\\s+import\\s+([\\w,\\s*]+)/m;\nconst RE_REQ_CALL = /\\brequests\\.(get|post|put|delete)\\s*\\(/g;\nconst RE_DIRECT_CALL = /\\b(get|post|put|delete)\\s*\\(/g;\nconst SKIP_DIRS = new Set([\n  \"node_modules\",\n  \".git\",\n  \"venv\",\n  \".venv\",\n  \"__pycache__\",\n]);\n\nfunction walk(dir: string, out: string[] = []) {\n  for (const f of fs.readdirSync(dir)) {\n    if (SKIP_DIRS.has(f) || f.startsWith(\".\")) continue;\n    const p = path.join(dir, f);\n    const stat = fs.statSync(p);\n    if (stat.isDirectory()) walk(p, out);\n    else if (stat.isFile() && f.endsWith(\".py\")) out.push(p);\n  }\n  return out;\n}\n\nexport function pyRequestsToHttpxDryRun({\n  root = process.cwd(),\n  dryRun = true,\n  maxFiles = GUARDS.maxFiles,\n  maxLines = GUARDS.maxLines,\n} = {}) {\n  const files = walk(root);\n  let candidates: { file: string; line: number; call: string }[] = [];\n  let importCount = 0;\n  let notes: string[] = [\"no mutations performed\"];\n  for (const file of files) {\n    const src = fs.readFileSync(file, \"utf8\");\n    let hasImport = RE_IMPORT.test(src);\n    let fromImport = RE_FROM_IMPORT.exec(src);\n    if (hasImport) importCount++;\n    // requests.<method>\n    let m;\n    while ((m = RE_REQ_CALL.exec(src))) {\n      const idx = src.slice(0, m.index).split(/\\r?\\n/).length;\n      candidates.push({ file, line: idx, call: `requests.${m[1]}` });\n    }\n    // direct method calls if from-import\n    if (fromImport) {\n      const methods = fromImport[1].split(\",\").map((s) => s.trim());\n      let direct = src.matchAll(RE_DIRECT_CALL);\n      for (const d of direct) {\n        if (methods.includes(d[1])) {\n          const idx = src.slice(0, d.index!).split(/\\r?\\n/).length;\n          candidates.push({ file, line: idx, call: d[1] });\n        }\n      }\n    }\n  }\n  const filesTouched = new Set(candidates.map((c) => c.file)).size;\n  const linesTouched =\n    candidates.length + (filesTouched > 0 ? 2 * filesTouched : 0);\n  const guardHit = filesTouched > maxFiles || linesTouched > maxLines;\n  notes.push(`detected 'import requests' in ${importCount} files`);\n  notes.push(\n    \"use httpx.Client() for session-based equivalents (not auto-applied in dry-run)\",\n  );\n  return {\n    recipe: \"py-requests-to-httpx\",\n    dryRun: true,\n    candidates,\n    changes: { files: filesTouched, lines: linesTouched },\n    guards: { maxFiles, maxLines, guardHit },\n    notes,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\remove-unused-imports.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":1,"column":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export function removeUnusedImports(file: string) {\n  // No-op placeholder\n  return { changed: false, message: 'noop' };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\src\\depsPatchMinor.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\src\\depsPatchMinor.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":14,"column":7}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { readFileSync, existsSync } from \"fs\";\nimport { execSync } from \"child_process\";\nimport { join } from \"path\";\n\n/**\n * Dependencies Patch/Minor upgrade codemod with OSV security integration\n * - Reads package.json files in workspace\n * - Uses `pnpm outdated --json` to find upgrades\n * - Uses OSV scanner for security recommendations (best-effort)\n * - Suggests only patch/minor upgrades (respects ^ and ~)\n * - Dry-run by default (no file writes)\n */\nexport async function depsPatchMinor(\n  root: string,\n): Promise<{\n  changes: Array<{\n    path: string;\n    name: string;\n    from: string;\n    to: string;\n    reason?: string;\n  }>;\n}> {\n  const changes: Array<{\n    path: string;\n    name: string;\n    from: string;\n    to: string;\n    reason?: string;\n  }> = [];\n\n  try {\n    const osvSafe = await getOsvSafeVersions(root);\n    const outdatedData = await getOutdatedPackages(root);\n    const packagePaths = await findPackageJsonFiles(root);\n\n    for (const pkgPath of packagePaths) {\n      const packageChanges = processPackageFile(pkgPath, outdatedData, osvSafe);\n      changes.push(...packageChanges);\n    }\n  } catch {\n    // Best-effort: return empty changes if anything fails\n  }\n\n  return { changes };\n}\n\nasync function getOutdatedPackages(root: string): Promise<any> {\n  const outdatedOutput = execSync(\"pnpm outdated --json\", {\n    cwd: root,\n    encoding: \"utf8\",\n    timeout: 10000,\n    stdio: \"pipe\",\n  });\n  return JSON.parse(outdatedOutput);\n}\n\nfunction processPackageFile(\n  pkgPath: string,\n  outdatedData: any,\n  osvSafe: { [key: string]: string },\n): Array<{\n  path: string;\n  name: string;\n  from: string;\n  to: string;\n  reason?: string;\n}> {\n  const changes: Array<{\n    path: string;\n    name: string;\n    from: string;\n    to: string;\n    reason?: string;\n  }> = [];\n  const pkg = JSON.parse(readFileSync(pkgPath, \"utf8\"));\n\n  for (const section of [\"dependencies\", \"devDependencies\"]) {\n    if (!pkg[section]) continue;\n\n    const sectionChanges = processDependencySection(\n      pkg[section],\n      outdatedData,\n      osvSafe,\n      pkgPath,\n    );\n    changes.push(...sectionChanges);\n  }\n\n  return changes;\n}\n\nfunction processDependencySection(\n  dependencies: { [key: string]: string },\n  outdatedData: any,\n  osvSafe: { [key: string]: string },\n  pkgPath: string,\n): Array<{\n  path: string;\n  name: string;\n  from: string;\n  to: string;\n  reason?: string;\n}> {\n  const changes: Array<{\n    path: string;\n    name: string;\n    from: string;\n    to: string;\n    reason?: string;\n  }> = [];\n\n  for (const [name, currentRange] of Object.entries(dependencies)) {\n    const outdatedInfo = outdatedData[name];\n    if (!outdatedInfo) continue;\n\n    const { current, latest } = outdatedInfo;\n    const { targetVersion, reason } = determineTargetVersion(\n      current,\n      latest,\n      osvSafe[name],\n    );\n\n    if (isPatchOrMinorUpgrade(current, targetVersion, currentRange)) {\n      changes.push({\n        path: pkgPath,\n        name,\n        from: currentRange,\n        to: updateVersionRange(currentRange, targetVersion),\n        reason,\n      });\n    }\n  }\n\n  return changes;\n}\n\nfunction determineTargetVersion(\n  current: string,\n  latest: string,\n  osvVersion?: string,\n): { targetVersion: string; reason: string } {\n  // Prefer OSV safe version if within same major, otherwise use latest\n  if (osvVersion && isWithinSameMajor(current, osvVersion)) {\n    return { targetVersion: osvVersion, reason: \"osv\" };\n  }\n\n  return { targetVersion: latest, reason: \"outdated\" };\n}\n\nasync function getOsvSafeVersions(\n  root: string,\n): Promise<{ [pkgName: string]: string }> {\n  try {\n    const lockfilePath = join(root, \"pnpm-lock.yaml\");\n    if (!existsSync(lockfilePath)) return {};\n\n    const osvOutput = execSync(\n      `osv-scanner --format json --lockfile ${lockfilePath}`,\n      {\n        cwd: root,\n        encoding: \"utf8\",\n        timeout: 15000,\n        stdio: \"pipe\",\n      },\n    );\n\n    const osvData = JSON.parse(osvOutput);\n    const safeVersions: { [pkgName: string]: string } = {};\n\n    osvData.results?.forEach((result: any) => {\n      result.packages?.forEach((pkg: any) => {\n        if (pkg.package?.name) {\n          const fixedVersion = extractFixedVersion(result.vulnerabilities);\n          if (fixedVersion) safeVersions[pkg.package.name] = fixedVersion;\n        }\n      });\n    });\n\n    return safeVersions;\n  } catch {\n    return {}; // OSV scan failed - proceed without OSV data\n  }\n}\n\nfunction extractFixedVersion(vulnerabilities: any[]): string | null {\n  for (const vuln of vulnerabilities || []) {\n    const events = vuln.affected?.[0]?.ranges?.[0]?.events;\n    if (events) {\n      const fixedEvent = events.find((e: any) => e.fixed);\n      if (fixedEvent?.fixed && /^\\d+\\.\\d+\\.\\d+/.test(fixedEvent.fixed)) {\n        return fixedEvent.fixed;\n      }\n    }\n  }\n  return null;\n}\n\nasync function findPackageJsonFiles(root: string): Promise<string[]> {\n  const packagePaths: string[] = [join(root, \"package.json\")];\n\n  try {\n    const workspaceConfig = readFileSync(\n      join(root, \"pnpm-workspace.yaml\"),\n      \"utf8\",\n    );\n    const workspaceRegex = /packages:\\s*\\n((?:\\s*-\\s*.+\\n)*)/;\n    const workspaceMatch = workspaceRegex.exec(workspaceConfig);\n\n    if (workspaceMatch) {\n      const globs = workspaceMatch[1]\n        .split(\"\\n\")\n        .map((line) => line.replace(/^\\s*-\\s*['\"]?(.+?)['\"]?\\s*$/, \"$1\"))\n        .filter(Boolean);\n\n      for (const glob of globs) {\n        if (glob.endsWith(\"/*\")) {\n          const baseDir = glob.slice(0, -2);\n          packagePaths.push(join(root, baseDir, \"cli\", \"package.json\"));\n          packagePaths.push(join(root, baseDir, \"vscode-ext\", \"package.json\"));\n        }\n      }\n    }\n  } catch {\n    // Fallback to just root package.json\n  }\n\n  return packagePaths;\n}\n\nfunction isPatchOrMinorUpgrade(\n  current: string,\n  latest: string,\n  range: string,\n): boolean {\n  const currentMajor = parseInt(current.split(\".\")[0] || \"0\");\n  const latestMajor = parseInt(latest.split(\".\")[0] || \"0\");\n  return currentMajor === latestMajor && current !== latest;\n}\n\nfunction isWithinSameMajor(current: string, target: string): boolean {\n  const currentMajor = parseInt(current.split(\".\")[0] || \"0\");\n  const targetMajor = parseInt(target.split(\".\")[0] || \"0\");\n  return currentMajor === targetMajor;\n}\n\nfunction updateVersionRange(currentRange: string, newVersion: string): string {\n  if (currentRange.startsWith(\"^\")) return `^${newVersion}`;\n  if (currentRange.startsWith(\"~\")) return `~${newVersion}`;\n  return newVersion;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\src\\esmHygiene.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\src\\esmHygiene.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":11,"column":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { readFileSync } from \"fs\";\nimport { PatchSet, Patch } from \"./types.js\";\n\n/**\n * ESM Hygiene codemod: Ensures explicit \".js\" extensions in ESM imports\n * - Transforms relative imports (./x -> ./x.js, ../x -> ../x.js)\n * - Skips require() statements and protected paths\n * - Idempotent and safe textual transformations only\n * - Guards: maxLinesPerPatch=40, maxFilesTouched=10\n */\nexport async function esmHygiene(files: string[]): Promise<PatchSet> {\n  const patches: Patch[] = [];\n  const maxFilesTouched = 10;\n  const maxLinesPerPatch = 40;\n\n  // Guard: limit files processed\n  const filesToProcess = files.slice(0, maxFilesTouched);\n\n  for (const file of filesToProcess) {\n    // Skip protected paths\n    if (\n      file.includes(\"/security/\") ||\n      file.includes(\".spec.\") ||\n      file.includes(\"/public-api/\")\n    ) {\n      continue;\n    }\n\n    try {\n      const content = readFileSync(file, \"utf8\");\n      const lines = content.split(\"\\n\");\n\n      // Guard: limit lines per file\n      if (lines.length > maxLinesPerPatch) {\n        continue;\n      }\n\n      let hasChanges = false;\n      const newLines = lines.map((line) => {\n        // Skip require() statements\n        if (line.includes(\"require(\")) {\n          return line;\n        }\n\n        // Transform ESM imports: add .js extension to relative paths\n        const importRegex =\n          /^(\\s*import\\s+.*?\\s+from\\s+['\"])(\\.\\.?\\/[^'\"]*?)(['\"])/;\n        const importMatch = importRegex.exec(line);\n        if (importMatch && !importMatch[2].endsWith(\".js\")) {\n          hasChanges = true;\n          return `${importMatch[1]}${importMatch[2]}.js${importMatch[3]}`;\n        }\n\n        return line;\n      });\n\n      if (hasChanges) {\n        const newContent = newLines.join(\"\\n\");\n        const diff = `--- ${file}\\n+++ ${file}\\n${generateDiff(content, newContent)}`;\n\n        patches.push({\n          file,\n          diff,\n          added: newLines.length - lines.length,\n          removed: 0,\n        });\n      }\n    } catch (error) {\n      // Log and skip files that can't be read\n      console.warn(\n        `ESM Hygiene: Unable to process file ${file}:`,\n        error instanceof Error ? error.message : String(error),\n      );\n      continue;\n    }\n  }\n\n  return {\n    patches,\n    totalChanges: patches.length,\n  };\n}\n\nfunction generateDiff(oldContent: string, newContent: string): string {\n  // Simple diff generation (placeholder)\n  const oldLines = oldContent.split(\"\\n\");\n  const newLines = newContent.split(\"\\n\");\n\n  let diff = \"\";\n  for (let i = 0; i < Math.max(oldLines.length, newLines.length); i++) {\n    if (oldLines[i] !== newLines[i]) {\n      if (oldLines[i]) diff += `-${oldLines[i]}\\n`;\n      if (newLines[i]) diff += `+${newLines[i]}\\n`;\n    }\n  }\n\n  return diff;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\src\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\src\\types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\codemods\\src\\types.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":2,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Minimal types for codemod operations\nexport interface Patch {\n  file: string;\n  diff: string;\n  added: number;\n  removed: number;\n}\n\nexport interface PatchSet {\n  patches: Patch[];\n  totalChanges: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\__tests__\\planner.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\__tests__\\planner.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\planner\\sort.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\planner\\sort.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":3,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { computeRiskTokens } from \"./tokens\";\n\nexport type PlanItem = {\n  id: string;\n  score: number;\n  risk: number;\n  recipeTrust?: number;\n};\nexport function sortBaseline(items: PlanItem[]): PlanItem[] {\n  return [...items].sort(\n    (a, b) =>\n      b.score -\n      b.risk +\n      (b.recipeTrust || 0) -\n      (a.score - a.risk + (a.recipeTrust || 0)),\n  );\n}\nexport function sortWithTokensV2(\n  items: PlanItem[],\n  ctx?: {\n    coveragePct: number;\n    flakeRate: number;\n    rollbacks30d: number;\n    repoSizeFactor: number;\n    base?: number;\n  },\n): PlanItem[] {\n  const t = computeRiskTokens(\n    ctx || {\n      coveragePct: 0.75,\n      flakeRate: 0.05,\n      rollbacks30d: 0,\n      repoSizeFactor: 0.3,\n      base: 10,\n    },\n  ).tokens;\n  return [...items].sort((a, b) => {\n    const sa = a.score - a.risk + (a.recipeTrust || 0) + 0.1 * t;\n    const sb = b.score - b.risk + (b.recipeTrust || 0) + 0.1 * t;\n    return sb - sa;\n  });\n}\n\n// Minimal sort implementation for test\nexport function sort(arr: number[]): number[] {\n  return [...arr].sort((a, b) => a - b);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\planner\\tokens.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\planner\\tokens.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":1,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type TokensInput = {\n  coveragePct: number; // 0..1\n  flakeRate: number; // 0..1\n  rollbacks30d: number; // 0..10\n  repoSizeFactor: number; // 0..1\n  base?: number; // 5..15 (default 10)\n};\nexport function computeRiskTokens(i: TokensInput) {\n  const base = Math.min(15, Math.max(5, i.base ?? 10));\n  const k1 = 5,\n    k2 = 8,\n    k3 = 1,\n    k4 = 3;\n  const raw =\n    base +\n    k1 * (i.coveragePct || 0) -\n    k2 * (i.flakeRate || 0) -\n    k3 * (i.rollbacks30d || 0) -\n    k4 * (i.repoSizeFactor || 0);\n  const tokens = Math.min(25, Math.max(5, Math.round(raw)));\n  return { tokens, base, k: { k1, k2, k3, k4 }, input: i };\n}\n\n// Minimal tokenize implementation for test\nexport function tokenize(str: string): string[] {\n  return str.split(/\\s+/).filter(Boolean);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\vitest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\core\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\org-orchestrator\\__tests__\\scheduler.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\org-orchestrator\\scheduler.ts","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'_' is assigned a value but never used.","line":10,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Org-wide workflow scheduler for ODAVL\nexport interface RepoConfig {\n  name: string;\n  prPerDay: number;\n  ciMinutesPerHour: number;\n}\n\nexport async function scheduleWorkflows(repos: RepoConfig[], maxConcurrency = 2) {\n  let running = 0;\n  for (const _ of repos) {\n    if (running >= maxConcurrency) break;\n    // Simulate scheduling scanHealPrWorkflow\n    running++;\n    setTimeout(() => {\n      running--;\n      // In real use, would trigger Temporal workflow here\n    }, 100);\n  }\n  return running;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\packs\\go\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":4,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { spawnSync } from \"child_process\";\nimport { mkdirSync, writeFileSync, readdirSync, readFileSync } from \"fs\";\nimport { extname } from \"path\";\nexport type NotImplemented = { status: \"not-implemented\" };\nconst run = (cmd: string, args: string[]) =>\n  spawnSync(cmd, args, { encoding: \"utf-8\" });\n\nexport async function scan() {\n  return JSON.parse(readFileSync(\"reports/w5/go-scan-sample.json\", \"utf-8\"));\n}\n\nexport async function heal() {\n  const imports: any[] = [];\n  const deps: any[] = [];\n\n  function collectImports() {\n    try {\n      for (const f of readdirSync(\".\")) {\n        if (extname(f) === \".go\") {\n          const s = readFileSync(f, \"utf-8\");\n          const im = Array.from(\n            s.matchAll(/import\\s*(?:\\(\\s*)?[\"']?([\\w./]+)[\"']?/g),\n          ).map((m) => m[1]);\n          const removals: string[] = [];\n          for (const name of im) {\n            const rx = new RegExp(`\\\\b${name.split(\"/\").pop()}\\\\b`);\n            if (!rx.test(s.replace(/import[\\s\\S]*?\\)/g, \"\")))\n              removals.push(name);\n          }\n          if (removals.length) imports.push({ file: f, removals });\n        }\n      }\n    } catch {}\n  }\n\n  function collectDeps() {\n    try {\n      const r = run(\"go\", [\"list\", \"-m\", \"-u\", \"-json\", \"all\"]);\n      if (r.status === 0 && r.stdout) {\n        const j = r.stdout\n          .split(\"\\n}\\n\")\n          .map((chunk: string) => {\n            try {\n              return JSON.parse(chunk + \"}\");\n            } catch {\n              return null;\n            }\n          })\n          .filter(Boolean);\n        for (const m of j as {\n          Path?: string;\n          Version?: string;\n          Update?: { Version?: string };\n        }[]) {\n          if (m && m.Update && m.Update.Version && m.Version) {\n            const from = m.Version,\n              to = m.Update.Version;\n            const minor = (a: string) => a.split(\".\").slice(0, 2).join(\".\");\n            if (\n              minor(from) === minor(to) ||\n              from.split(\".\")[0] === to.split(\".\")[0]\n            )\n              deps.push({ module: m.Path, from, to });\n          }\n        }\n      }\n    } catch {}\n  }\n\n  collectImports();\n  collectDeps();\n  const out = { imports, deps };\n  mkdirSync(\"reports/w5\", { recursive: true });\n  writeFileSync(\n    \"reports/w5/go-heal-proposals.json\",\n    JSON.stringify(out, null, 2),\n  );\n  return out;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\packs\\go\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\packs\\java\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":11,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { spawnSync } from \"child_process\";\nimport {\n  existsSync,\n  mkdirSync,\n  writeFileSync,\n  readdirSync,\n  readFileSync,\n} from \"fs\";\nimport { extname } from \"path\";\n\nexport type NotImplemented = { status: \"not-implemented\" };\nconst run = (cmd: string, args: string[]) =>\n  spawnSync(cmd, args, { encoding: \"utf-8\" });\n\nexport async function scan() {\n  return JSON.parse(readFileSync(\"reports/w5/java-scan-sample.json\", \"utf-8\"));\n}\n\nexport async function heal() {\n  const imports: any[] = [];\n  const deps: any[] = [];\n\n  function collectImports() {\n    try {\n      for (const f of readdirSync(\".\")) {\n        if (extname(f) === \".java\") {\n          const s = readFileSync(f, \"utf-8\");\n          const im = Array.from(\n            s.matchAll(/import\\s+([\\w.]+)\\.([A-Z]\\w*)\\s*;/g),\n          ).map((m) => {\n            const match = m as RegExpMatchArray;\n            return { fqn: match[1] + \".\" + match[2], sym: match[2] };\n          });\n          const body = s.replace(/import[\\s\\S]*?;/g, \"\");\n          const removals: string[] = [];\n          for (const { fqn, sym } of im) {\n            if (!new RegExp(`\\\\b${sym}\\\\b`).test(body)) removals.push(fqn);\n          }\n          if (removals.length) imports.push({ file: f, removals });\n        }\n      }\n    } catch {}\n  }\n\n  function collectDeps() {\n    try {\n      if (existsSync(\"pom.xml\")) {\n        const r = run(\"mvn\", [\"-q\", \"versions:display-dependency-updates\"]);\n        const lines = (r.stdout || \"\")\n          .split(\"\\n\")\n          .filter((l: string) => l.includes(\" -> \"));\n        for (const l of lines) {\n          const m = l.match(\n            /([\\w\\-.]+):([\\w\\-.]+)\\s*\\.*\\s*([\\w\\-.]+)\\s*->\\s*([\\w\\-.]+)/,\n          );\n          if (!m) continue;\n          const module = `${m[1]}:${m[2]}`;\n          const from = m[3],\n            to = m[4];\n          const major = (v: string) => v.split(\".\")[0];\n          if (major(from) === major(to))\n            deps.push({ tool: \"maven\", module, from, to });\n        }\n      } else if (existsSync(\"build.gradle\") || existsSync(\"gradlew\")) {\n        // Best-effort: we can only surface placeholders without running heavy tasks.\n        // Propose empty list for now; future stages may enhance.\n      }\n    } catch {}\n  }\n\n  collectImports();\n  collectDeps();\n  const out = { imports, deps };\n  mkdirSync(\"reports/w5\", { recursive: true });\n  writeFileSync(\n    \"reports/w5/java-heal-proposals.json\",\n    JSON.stringify(out, null, 2),\n  );\n  return out;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\packs\\java\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\packs\\python\\src\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":2,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { execJson } from \"./shell\";\nexport type PyScan = {\n  ruff?: number;\n  tests?: { failures?: number };\n  vulns?: number;\n  note: string;\n};\nexport async function scan(): Promise<PyScan> {\n  // Helper to run a linter and parse count\n  function getLintCount(\n    cmd: string[],\n    fallbackCmd?: string[],\n  ): { count?: number; note: string } {\n    const res = execJson(cmd);\n    if (res.ok) {\n      try {\n        const parsed = JSON.parse(res.stdout);\n        return {\n          count: Array.isArray(parsed) ? parsed.length : undefined,\n          note: \"\",\n        };\n      } catch {\n        return { count: undefined, note: `${cmd[0]} output parse error` };\n      }\n    } else if (fallbackCmd) {\n      const fallback = execJson(fallbackCmd);\n      if (fallback.ok) {\n        return {\n          count: fallback.stdout.split(\"\\n\").filter(Boolean).length,\n          note: `${cmd[0]} missing, used ${fallbackCmd[0]}`,\n        };\n      } else {\n        return {\n          count: undefined,\n          note: `${cmd[0]}/${fallbackCmd[0]} missing`,\n        };\n      }\n    } else {\n      return { count: undefined, note: `${cmd[0]} missing` };\n    }\n  }\n\n  // Ruff or flake8\n  const { count: ruff, note: ruffNote } = getLintCount(\n    [\"ruff\", \"--output-format=json\", \".\"],\n    [\"flake8\", \".\"],\n  );\n\n  // Pytest\n  function getTestFailures(): { failures?: number; note: string } {\n    const pyRes = execJson([\"pytest\", \"-q\", \"--maxfail=1\"]);\n    if (pyRes.ok) return { failures: 0, note: \"\" };\n    if (pyRes.code !== 1 && pyRes.stderr.includes(\"not found\"))\n      return { failures: undefined, note: \"pytest missing\" };\n    if (pyRes.stdout.includes(\"no tests ran\")) return { failures: 0, note: \"\" };\n    return { failures: 1, note: \"\" };\n  }\n  const { failures, note: testNote } = getTestFailures();\n\n  // pip-audit\n  const { count: vulns, note: vulnNote } = getLintCount([\n    \"pip-audit\",\n    \"-f\",\n    \"json\",\n  ]);\n\n  let notes = [ruffNote, testNote, vulnNote].filter(Boolean).join(\"; \");\n  return {\n    ruff,\n    tests: { failures },\n    vulns,\n    note: \"python.scan ok\" + (notes ? \" | \" + notes : \"\"),\n  };\n}\nexport type PyHealResult = {\n  dryRun: boolean;\n  changes?: { files: number; lines: number };\n  actions?: {\n    unusedImports?: { files: number; lines: number; note?: string };\n    format?: { files: number; lines: number; note?: string };\n    deps?: { candidates: number; note?: string };\n  };\n  guards?: { maxFiles: number; maxLines: number; guardHit: boolean };\n  note: string;\n};\nexport async function heal(\n  opts: { dryRun?: boolean; maxFiles?: number; maxLines?: number } = {},\n): Promise<PyHealResult> {\n  const maxFiles = typeof opts.maxFiles === \"number\" ? opts.maxFiles : 10;\n  const maxLines = typeof opts.maxLines === \"number\" ? opts.maxLines : 40;\n  let notes: string[] = [];\n\n  // Helper for ruff unused imports\n  function getUnusedImports() {\n    const ruff = execJson([\n      \"ruff\",\n      \"--fix-dry-run\",\n      \"--exit-zero-even-if-changed\",\n      \".\",\n    ]);\n    if (ruff.ok) {\n      const lines = ruff.stdout.split(\"\\n\");\n      const unusedFiles = lines.filter((l) => /would fix|Fixed/.test(l)).length;\n      const unusedLines = unusedFiles; // Approximate: 1 line per file\n      let unusedNote = \"\";\n      if (unusedFiles === 0 && ruff.stdout?.includes(\"No changes\"))\n        unusedNote = \"no unused imports\";\n      return { unusedFiles, unusedLines, unusedNote };\n    } else {\n      return { unusedFiles: 0, unusedLines: 0, unusedNote: \"ruff missing\" };\n    }\n  }\n\n  // Helper for black format\n  function getFormatCheck() {\n    const black = execJson([\"black\", \"--check\", \".\"]);\n    if (!black.ok) {\n      const match = black.stdout.match(/would reformat (.+)/g);\n      return {\n        fmtFiles: match ? match.length : 1,\n        fmtLines: 0,\n        fmtNote: \"format needed\",\n      };\n    }\n    return { fmtFiles: 0, fmtLines: 0, fmtNote: \"\" };\n  }\n\n  // Helper for pip outdated\n  function getDepCandidates() {\n    const pip = execJson([\"pip\", \"list\", \"--outdated\", \"--format=json\"]);\n    if (pip.ok) {\n      try {\n        const parsed = JSON.parse(pip.stdout);\n        return {\n          depCandidates: Array.isArray(parsed) ? parsed.length : 0,\n          depNote: \"\",\n        };\n      } catch {\n        return { depCandidates: 0, depNote: \"pip list parse error\" };\n      }\n    } else {\n      return { depCandidates: 0, depNote: \"pip missing\" };\n    }\n  }\n\n  const { unusedFiles, unusedLines, unusedNote } = getUnusedImports();\n  if (unusedNote === \"ruff missing\") notes.push(\"ruff missing\");\n  const { fmtFiles, fmtLines, fmtNote } = getFormatCheck();\n  const { depCandidates, depNote } = getDepCandidates();\n  if (depNote === \"pip missing\") notes.push(\"pip missing\");\n\n  // Guard logic\n  const totalFiles = unusedFiles + fmtFiles + depCandidates;\n  const totalLines = unusedLines + fmtLines;\n  const guardHit = totalFiles > maxFiles || totalLines > maxLines;\n  let guardNote = \"\";\n  if (guardHit) guardNote = \"guard hit: would split into waves\";\n\n  // Compose result\n  return {\n    dryRun: true,\n    changes: { files: totalFiles, lines: totalLines },\n    actions: {\n      unusedImports: {\n        files: unusedFiles,\n        lines: unusedLines,\n        note: unusedNote,\n      },\n      format: { files: fmtFiles, lines: fmtLines, note: fmtNote },\n      deps: { candidates: depCandidates, note: depNote },\n    },\n    guards: { maxFiles, maxLines, guardHit },\n    note:\n      [notes.join(\"; \"), guardNote].filter(Boolean).join(\" | \") ||\n      \"python.heal dry-run ok\",\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\packs\\python\\src\\shell.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":3,"column":6}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { spawnSync } from \"child_process\";\nexport function execJson(\n  cmd: string[],\n  cwd = process.cwd(),\n): { ok: boolean; code: number; stdout: string; stderr: string } {\n  try {\n    const p = spawnSync(cmd[0], cmd.slice(1), {\n      cwd,\n      encoding: \"utf8\",\n      timeout: 20000,\n    });\n    return {\n      ok: p.status === 0,\n      code: p.status ?? 1,\n      stdout: p.stdout || \"\",\n      stderr: p.stderr || \"\",\n    };\n  } catch (e) {\n    return {\n      ok: false,\n      code: 1,\n      stdout: \"\",\n      stderr:\n        e && typeof e === \"object\" && \"message\" in e\n          ? (e as any).message\n          : String(e),\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\__tests__\\baseline.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\__tests__\\org-policy.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\__tests__\\rbac.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\index.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\smoke.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\governor.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":1,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface GovernorCfg {\n    prsPerDay?: number;\n    ciMinutesPerHour?: number;\n    maxConcurrentShadows?: number;\n    waves?: Array<{\n        window?: string;\n        maxPrs?: number;\n    }>;\n}\nexport interface GovernorUsage {\n    openPrsToday: number;\n    shadowsInProgress: number;\n    estCiMinsHour: number;\n}\nexport interface GovernorDecision {\n    blocked: boolean;\n    reason?: string;\n    limits: GovernorCfg;\n    usage: GovernorUsage;\n}\nexport declare function readGovernorConfig(root: string): GovernorCfg;\nexport declare function currentUsage(root: string): GovernorUsage;\nexport declare function parseWindow(str: string): {\n    startMinutes: number;\n    endMinutes: number;\n} | null;\nexport declare function isWithin(nowLocalMinutes: number, win: {\n    startMinutes: number;\n    endMinutes: number;\n}): boolean;\nexport declare function nextWaveStart(nowLocalMinutes: number, win: {\n    startMinutes: number;\n    endMinutes: number;\n}): number;\nexport declare function decide(kind: \"pr\" | \"shadow\", cfg: GovernorCfg, usage: GovernorUsage): GovernorDecision;\n//# sourceMappingURL=governor.d.ts.map","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\governor.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\governor.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token interface","line":5,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { execSync } from \"child_process\";\nimport { readFileSync, writeFileSync, existsSync } from \"fs\";\nimport path from \"path\";\n\nexport interface GovernorCfg {\n  prsPerDay?: number;\n  ciMinutesPerHour?: number;\n  maxConcurrentShadows?: number;\n  waves?: Array<{\n    window?: string; // \"HH:MM-HH:MM\" format\n    maxPrs?: number;\n  }>;\n}\n\nexport interface GovernorUsage {\n  openPrsToday: number;\n  shadowsInProgress: number;\n  estCiMinsHour: number;\n}\n\nexport interface GovernorDecision {\n  blocked: boolean;\n  reason?: string;\n  limits: GovernorCfg;\n  usage: GovernorUsage;\n}\n\n// Best-effort YAML parsing for governor config\nexport function readGovernorConfig(root: string): GovernorCfg {\n  const defaults: GovernorCfg = {\n    prsPerDay: 2,\n    ciMinutesPerHour: 30,\n    maxConcurrentShadows: 2,\n  };\n\n  try {\n    const policyPath = path.join(root, \".odavl.policy.yml\");\n    if (!existsSync(policyPath)) {\n      return defaults;\n    }\n\n    const content = readFileSync(policyPath, \"utf8\");\n    const cfg: GovernorCfg = { ...defaults };\n\n    // Simple regex-based YAML parsing for governor section\n    const governorRegex = /governor:\\s*\\n((?:\\s+\\w+:.*\\n?)*)/;\n    const governorMatch = governorRegex.exec(content);\n    if (governorMatch) {\n      const governorSection = governorMatch[1];\n\n      const prsRegex = /prsPerDay:\\s*(\\d+)/;\n      const prsMatch = prsRegex.exec(governorSection);\n      if (prsMatch) cfg.prsPerDay = parseInt(prsMatch[1], 10);\n\n      const ciRegex = /ciMinutesPerHour:\\s*(\\d+)/;\n      const ciMatch = ciRegex.exec(governorSection);\n      if (ciMatch) cfg.ciMinutesPerHour = parseInt(ciMatch[1], 10);\n\n      const shadowsRegex = /maxConcurrentShadows:\\s*(\\d+)/;\n      const shadowsMatch = shadowsRegex.exec(governorSection);\n      if (shadowsMatch)\n        cfg.maxConcurrentShadows = parseInt(shadowsMatch[1], 10);\n    }\n\n    return cfg;\n  } catch {\n    return defaults;\n  }\n}\n\n// Query current usage from GitHub API\nexport function currentUsage(root: string): GovernorUsage {\n  const usage: GovernorUsage = {\n    openPrsToday: 0,\n    shadowsInProgress: 0,\n    estCiMinsHour: 0,\n  };\n\n  try {\n    // Count open PRs created today\n    const prResult = execSync(\n      \"gh pr list --state open --json createdAt,headRefName\",\n      {\n        encoding: \"utf8\",\n        timeout: 10000,\n      },\n    );\n    const prs = JSON.parse(prResult);\n    const today = new Date().toISOString().split(\"T\")[0];\n\n    usage.openPrsToday = prs.filter((pr: any) =>\n      pr.createdAt?.startsWith(today),\n    ).length;\n\n    // Count shadows (CI runs) in progress\n    const runResult = execSync(\n      \"gh run list --status in_progress --json status,headBranch,displayTitle\",\n      {\n        encoding: \"utf8\",\n        timeout: 10000,\n      },\n    );\n    const runs = JSON.parse(runResult);\n    usage.shadowsInProgress = runs.length;\n\n    // Estimate CI minutes per hour (rough heuristic)\n    const cfg = readGovernorConfig(root);\n    usage.estCiMinsHour = Math.min(\n      usage.shadowsInProgress * 10,\n      cfg.ciMinutesPerHour || 30,\n    );\n  } catch (error) {\n    // Best-effort: if GitHub CLI fails, return safe defaults\n    console.warn(\n      \"Governor: GitHub CLI command failed:\",\n      error instanceof Error ? error.message : String(error),\n    );\n  }\n\n  // Update ledger\n  updateLedger(root, usage);\n\n  return usage;\n}\n\n// Wave window helpers\nexport function parseWindow(\n  str: string,\n): { startMinutes: number; endMinutes: number } | null {\n  if (!str || typeof str !== \"string\") return null;\n\n  const windowRegex = /^(\\d{1,2}):(\\d{2})-(\\d{1,2}):(\\d{2})$/;\n  const match = windowRegex.exec(str);\n  if (!match) return null;\n\n  const [, startH, startM, endH, endM] = match;\n  const startMinutes = parseInt(startH) * 60 + parseInt(startM);\n  const endMinutes = parseInt(endH) * 60 + parseInt(endM);\n\n  return { startMinutes, endMinutes };\n}\n\nexport function isWithin(\n  nowLocalMinutes: number,\n  win: { startMinutes: number; endMinutes: number },\n): boolean {\n  const { startMinutes, endMinutes } = win;\n\n  if (startMinutes <= endMinutes) {\n    // Same day window: 09:00-17:00\n    return nowLocalMinutes >= startMinutes && nowLocalMinutes <= endMinutes;\n  } else {\n    // Overnight window: 22:00-06:00\n    return nowLocalMinutes >= startMinutes || nowLocalMinutes <= endMinutes;\n  }\n}\n\nexport function nextWaveStart(\n  nowLocalMinutes: number,\n  win: { startMinutes: number; endMinutes: number },\n): number {\n  const { startMinutes } = win;\n\n  if (nowLocalMinutes < startMinutes) {\n    // Next start is today\n    return startMinutes;\n  } else {\n    // Next start is tomorrow\n    return startMinutes + 1440; // +24 hours in minutes\n  }\n}\n\n// Decision logic for governor actions\nexport function decide(\n  kind: \"pr\" | \"shadow\",\n  cfg: GovernorCfg,\n  usage: GovernorUsage,\n): GovernorDecision {\n  const decision: GovernorDecision = {\n    blocked: false,\n    limits: cfg,\n    usage,\n  };\n\n  // Check wave window if configured\n  const wave = cfg.waves?.[0];\n  const window = wave?.window ? parseWindow(wave.window) : null;\n\n  if (window) {\n    const now = new Date();\n    const nowLocalMinutes = now.getHours() * 60 + now.getMinutes();\n    const inWindow = isWithin(nowLocalMinutes, window);\n\n    if (!inWindow && kind === \"pr\" && (cfg.prsPerDay || 0) > 0) {\n      // Block PRs outside wave window when PR limits are set\n      const nextStart = nextWaveStart(nowLocalMinutes, window);\n      const nextHour = Math.floor((nextStart % 1440) / 60);\n      const nextMin = (nextStart % 1440) % 60;\n      const nextWindow = `${nextHour.toString().padStart(2, \"0\")}:${nextMin.toString().padStart(2, \"0\")}`;\n\n      decision.blocked = true;\n      decision.reason = \"outside_wave_window\";\n      (decision as any).nextWindow = nextWindow;\n      return decision;\n    }\n  }\n\n  if (kind === \"pr\") {\n    if (usage.openPrsToday >= (cfg.prsPerDay || 2)) {\n      decision.blocked = true;\n      decision.reason = `PR limit reached: ${usage.openPrsToday}/${cfg.prsPerDay} per day`;\n    }\n  } else if (kind === \"shadow\") {\n    if (usage.shadowsInProgress >= (cfg.maxConcurrentShadows || 2)) {\n      decision.blocked = true;\n      decision.reason = `Shadow limit reached: ${usage.shadowsInProgress}/${cfg.maxConcurrentShadows} concurrent`;\n    } else if (usage.estCiMinsHour >= (cfg.ciMinutesPerHour || 30)) {\n      decision.blocked = true;\n      decision.reason = `CI time limit reached: ${usage.estCiMinsHour}/${cfg.ciMinutesPerHour} minutes/hour`;\n    }\n  }\n\n  return decision;\n}\n\n// Maintain simple ledger for tracking\nfunction updateLedger(root: string, usage: GovernorUsage): void {\n  try {\n    const ledgerPath = path.join(root, \"reports\", \"governor_ledger.json\");\n    const timestamp = new Date().toISOString();\n\n    let ledger: any[] = [];\n    if (existsSync(ledgerPath)) {\n      const content = readFileSync(ledgerPath, \"utf8\");\n      ledger = JSON.parse(content);\n    }\n\n    // Keep only last 24 entries (roughly hourly samples)\n    ledger.push({ timestamp, ...usage });\n    if (ledger.length > 24) {\n      ledger = ledger.slice(-24);\n    }\n\n    writeFileSync(ledgerPath, JSON.stringify(ledger, null, 2));\n  } catch {\n    // Best-effort: ignore ledger failures\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\index.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token GovernorCfg","line":1,"column":95}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export { readGovernorConfig, currentUsage, decide, parseWindow, isWithin, nextWaveStart, type GovernorCfg, type GovernorUsage, type GovernorDecision, } from \"./governor.js\";\nexport { enforceRbac, loadRbacConfig } from \"./rbac.js\";\nexport type { RbacRole } from \"./rbac.schema.js\";\nexport { validateOrgPolicy } from \"./org-policy.js\";\n//# sourceMappingURL=index.d.ts.map","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token GovernorCfg","line":8,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export {\n  readGovernorConfig,\n  currentUsage,\n  decide,\n  parseWindow,\n  isWithin,\n  nextWaveStart,\n  type GovernorCfg,\n  type GovernorUsage,\n  type GovernorDecision,\n} from \"./governor.js\";\n\nexport { enforceRbac, loadRbacConfig } from \"./rbac.js\";\nexport type { RbacRole } from \"./rbac.schema.js\";\nexport { validateOrgPolicy } from \"./org-policy.js\";\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\org-policy.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token declare","line":1,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export declare function validateOrgPolicy(repoPolicies: any[]): {\n    ok: boolean;\n    errors: string[];\n};\n//# sourceMappingURL=org-policy.d.ts.map","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\org-policy.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\org-policy.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":2,"column":47}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Org-level policy enforcement for ODAVL\nexport function validateOrgPolicy(repoPolicies: any[]): {ok: boolean, errors: string[]} {\n  const errors: string[] = [];\n  // Example: enforce max PRs/day = min of all\n  const prs = repoPolicies.map(p => p.governor?.prsPerDay).filter(Boolean);\n  if (Math.min(...prs) !== Math.max(...prs)) {\n    errors.push('Conflicting prsPerDay across repos');\n  }\n  // Example: enforce max CI minutes/hour\n  const ci = repoPolicies.map(p => p.governor?.ciMinutesPerHour).filter(Boolean);\n  if (Math.min(...ci) !== Math.max(...ci)) {\n    errors.push('Conflicting ciMinutesPerHour across repos');\n  }\n  return { ok: errors.length === 0, errors };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\rbac.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token declare","line":2,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { RbacConfig, RbacRole, RbacAction } from './rbac.schema.js';\nexport declare function loadRbacConfig(path?: string): RbacConfig;\nexport declare function enforceRbac(action: RbacAction, role: RbacRole, configPath?: string): boolean;\n//# sourceMappingURL=rbac.d.ts.map","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\rbac.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\rbac.schema.d.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":1,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type RbacRole = 'viewer' | 'runner' | 'reviewer' | 'admin';\nexport type RbacAction = 'report.read' | 'scan.run' | 'heal.run' | 'shadow.run' | 'pr.open' | 'waiver.create' | '*';\nexport interface RbacRoleDef {\n    name: RbacRole;\n    allow: RbacAction[];\n}\nexport interface RbacScope {\n    type: 'repo' | 'org' | 'project' | 'path';\n    id: string;\n    protectedPaths?: string[];\n}\nexport interface RbacConfig {\n    version: number;\n    roles: RbacRoleDef[];\n    scopes: RbacScope[];\n}\n//# sourceMappingURL=rbac.schema.d.ts.map","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\rbac.schema.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\rbac.schema.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":2,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// RBAC schema/types for ODAVL Studio\nexport type RbacRole = 'viewer' | 'runner' | 'reviewer' | 'admin';\nexport type RbacAction =\n  | 'report.read'\n  | 'scan.run'\n  | 'heal.run'\n  | 'shadow.run'\n  | 'pr.open'\n  | 'waiver.create'\n  | '*';\nexport interface RbacRoleDef {\n  name: RbacRole;\n  allow: RbacAction[];\n}\nexport interface RbacScope {\n  type: 'repo' | 'org' | 'project' | 'path';\n  id: string;\n  protectedPaths?: string[];\n}\nexport interface RbacConfig {\n  version: number;\n  roles: RbacRoleDef[];\n  scopes: RbacScope[];\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\src\\rbac.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":6,"column":56}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// RBAC loader and enforcement stub\nimport fs from 'fs';\nimport yaml from 'js-yaml';\nimport { RbacConfig, RbacRole, RbacAction } from './rbac.schema.js';\n\nexport function loadRbacConfig(path = 'odavl.rbac.yml'): RbacConfig {\n  const raw = fs.readFileSync(path, 'utf8');\n  return yaml.load(raw) as RbacConfig;\n}\n\nexport function enforceRbac(action: RbacAction, role: RbacRole, configPath = 'odavl.rbac.yml'): boolean {\n  const config = loadRbacConfig(configPath);\n  const roleDef = config.roles.find(r => r.name === role);\n  if (!roleDef) return false;\n  if (roleDef.allow.includes('*')) return true;\n  return roleDef.allow.includes(action);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\policy\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\recipes-go\\__tests__\\gofmt-wrapper.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\recipes-go\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":2,"column":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Go recipe pack scaffold\nexport function detectGofmt(src: string): boolean {\n  return src.includes('package ');\n}\nexport function fixGofmt(src: string): string {\n  // Placeholder: would call gofmt\n  return src.trim();\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\recipes-java\\__tests__\\remove-unused-imports.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\recipes-java\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":2,"column":41}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Java recipe pack scaffold\nexport function detectUnusedImports(java: string): boolean {\n  return /import\\s+\\w+/.test(java);\n}\nexport function fixUnusedImports(java: string): string {\n  return java.replace(/^import\\s+\\w+.*$/gm, '');\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\recipes-python\\__tests__\\remove-unused-imports.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\recipes-python\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":2,"column":39}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Python recipe pack scaffold\nexport function detectUnusedImports(py: string): boolean {\n  return /import\\s+\\w+/.test(py);\n}\nexport function fixUnusedImports(py: string): string {\n  return py.replace(/^import\\s+\\w+.*$/gm, '');\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\recipes-security\\__tests__\\cve-fixer.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\recipes-security\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":2,"column":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// CVE fixer stub for OSV-Scanner JSON\nexport function parseOsvJson(input: string) {\n  try {\n    const data = JSON.parse(input);\n    // Example: find first vuln and suggest fixed version\n    const vuln = data.vulnerabilities?.[0];\n    if (vuln && vuln.package && vuln.versions?.fixed) {\n      return {\n        package: vuln.package.name,\n        current: vuln.versions.vulnerable,\n        fixed: vuln.versions.fixed\n      };\n    }\n  } catch {}\n  return null;\n}\n// CLI: odavl heal --recipe cve-fix --dry-run (integration stub)\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\reporters\\__tests__\\redacting-writer.spec.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\reporters\\__tests__\\redacting-writer.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\reporters\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\reporters\\src\\redacting-writer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\reporters\\src\\redacting-writer.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token :","line":3,"column":31}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Redacting writer for reporters\n// Stub redact until module is available\nexport function redactLine(msg: string) {\n  // Simple redaction: replace token=... with token=***REDACTED***\n  return msg.replace(/token=[^\\s]+/g, 'token=***REDACTED***');\n}\nexport function writeRedacted(msg: string) {\n  process.stdout.write(redactLine(msg));\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\reporters\\src\\telemetry.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\reporters\\src\\telemetry.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":5,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createHash } from \"crypto\";\nimport { writeFileSync, mkdirSync, existsSync } from \"fs\";\nimport { join } from \"path\";\n\nexport type TelemetryMode = \"off\" | \"on\" | \"anonymized\";\n\ninterface TelemetrySpan {\n  ts: string;\n  kind: string;\n  durMs: number;\n  ok: boolean;\n  repoHash?: string;\n  branchHash?: string;\n  extra?: Record<string, string | number>;\n}\n\ninterface SpanContext {\n  repo?: string;\n  branch?: string;\n}\n\nfunction hash(input: string): string {\n  return createHash(\"sha256\").update(input).digest(\"hex\").slice(0, 16);\n}\n\nfunction ensureReportsDir(): void {\n  try {\n    const reportsPath = join(process.cwd(), \"reports\");\n    if (!existsSync(reportsPath)) {\n      mkdirSync(reportsPath, { recursive: true });\n    }\n  } catch {\n    // Ignore errors\n  }\n}\n\nfunction writeToLog(span: TelemetrySpan): void {\n  try {\n    ensureReportsDir();\n    const logPath = join(process.cwd(), \"reports\", \"telemetry.log.jsonl\");\n    const line = JSON.stringify(span) + \"\\n\";\n    writeFileSync(logPath, line, { flag: \"a\" });\n  } catch {\n    // Never throw\n  }\n}\n\nasync function sendToEndpoint(span: TelemetrySpan): Promise<void> {\n  try {\n    const endpoint = process.env.ODAVL_TELEMETRY_ENDPOINT;\n    if (!endpoint) return;\n\n    await fetch(endpoint, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(span),\n    });\n\n    // Best-effort, ignore response\n  } catch {\n    // Ignore all errors\n  }\n}\n\nfunction createBaseSpan(\n  ts: string,\n  kind: string,\n  durMs: number,\n  ok: boolean,\n): TelemetrySpan {\n  return { ts, kind, durMs, ok };\n}\n\nfunction addContextToSpan(\n  span: TelemetrySpan,\n  mode: TelemetryMode,\n  ctx?: SpanContext,\n): void {\n  if (!ctx) return;\n\n  if (mode === \"on\") {\n    if (ctx.repo) span.repoHash = ctx.repo;\n    if (ctx.branch) span.branchHash = ctx.branch;\n  } else if (mode === \"anonymized\") {\n    if (ctx.repo) span.repoHash = hash(ctx.repo);\n    if (ctx.branch) span.branchHash = hash(ctx.branch);\n  }\n}\n\nfunction addExtraToSpan(\n  span: TelemetrySpan,\n  extra?: Record<string, any>,\n): void {\n  if (!extra) return;\n\n  const filteredExtra: Record<string, string | number> = {};\n  for (const [key, value] of Object.entries(extra)) {\n    if (typeof value === \"string\" || typeof value === \"number\") {\n      filteredExtra[key] = value;\n    }\n  }\n\n  if (Object.keys(filteredExtra).length > 0) {\n    span.extra = filteredExtra;\n  }\n}\n\nexport function startSpan(\n  kind: string,\n  mode: TelemetryMode,\n  ctx?: SpanContext,\n) {\n  if (mode === \"off\") {\n    return {\n      end(_ok: boolean, _extra?: Record<string, any>): void {\n        // No-op for off mode\n      },\n    };\n  }\n\n  const startTime = Date.now();\n  const ts = new Date().toISOString();\n\n  return {\n    end(ok: boolean, extra?: Record<string, any>): void {\n      const durMs = Date.now() - startTime;\n      const span = createBaseSpan(ts, kind, durMs, ok);\n\n      addContextToSpan(span, mode, ctx);\n      addExtraToSpan(span, extra);\n\n      writeToLog(span);\n\n      if (process.env.ODAVL_TELEMETRY_ENDPOINT) {\n        sendToEndpoint(span).catch(() => {}); // Fire and forget\n      }\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\validators\\auto.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token Contract","line":3,"column":50}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { mkdirSync, writeFileSync } from \"fs\";\nimport { basename } from \"path\";\nimport { defineContract, generateSmokeTest, type Contract } from \"./index\";\n\nexport type PreviewReg = {\n  fnPath: string;\n  inputsShape?: any;\n  outputsShape?: any;\n  critical?: boolean;\n};\nconst match = (p: string, target: string) =>\n  p === target || basename(p) === basename(target);\n\nexport function previewContractsForChanges(\n  changedPaths: string[],\n  registry: PreviewReg[],\n) {\n  const out: string[] = [];\n  const targets = new Set(changedPaths);\n  const list = (registry || []).filter((c) =>\n    Array.from(targets).some((p) => match(p, c.fnPath)),\n  );\n  if (!list.length) return { generated: out };\n  mkdirSync(\"reports/w5/contracts\", { recursive: true });\n  for (const c of list) {\n    const ct: Contract = defineContract({\n      fnPath: c.fnPath,\n      inputsShape: c.inputsShape || {},\n      outputsShape: c.outputsShape || {},\n      critical: c.critical,\n    });\n    const code = generateSmokeTest(ct);\n    const file = `reports/w5/contracts/${ct.id}.preview.test.js`;\n    writeFileSync(file, code);\n    out.push(file);\n  }\n  return { generated: out };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\validators\\index.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Unexpected token type","line":2,"column":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Buffer } from \"buffer\";\nexport type Contract = {\n  fnPath: string;\n  inputsShape: any;\n  outputsShape: any;\n  critical?: boolean;\n  id?: string;\n};\nexport function defineContract(c: Contract): Contract {\n  const id = Buffer.from(\n    `${c.fnPath}:${Object.keys(c.inputsShape || {}).join(\",\")}`,\n  )\n    .toString(\"base64url\")\n    .slice(0, 16);\n  return { ...c, id };\n}\nexport function generateSmokeTest(c: Contract): string {\n  const sIn = JSON.stringify(c.inputsShape ?? {});\n  const sOut = JSON.stringify(c.outputsShape ?? {});\n  return (\n    `// AUTO-GENERATED (preview)\\n` +\n    `const assert=require('node:assert');\\n` +\n    `const mod=require('${c.fnPath}');\\n` +\n    `const fn=(typeof mod==='function'?mod:mod.default||mod.fn);\\n` +\n    `assert.ok(typeof fn==='function','fn not found');\\n` +\n    `const out=fn(${sIn});\\n` +\n    `assert.ok(out!==undefined,'no output');\\n` +\n    `if (${sOut}!={}){ for(const k of Object.keys(${sOut})){ assert.ok(Object.hasOwn(out,k),'missing '+k); } }\\n`\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\packages\\validators\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\attest.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\bundle-report.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\check-waivers.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\codemods-test.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\compliance-check.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\compute-tokens.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\doctor.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\e2e-golden.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\e2e-polyglot.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\freeze-audit.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\gates-validate.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\go-report.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\antibodies-apply.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\antibodies.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\escalate.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\heal.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\heatmap.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\metrics.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\p0-attest.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\problems.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\problems\\apply.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\problems\\escalate.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\problems\\plan.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\problems\\run.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\problems\\scan.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\sensors.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\triage-lib.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\triage-verify.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\triage.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\undo.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\vaccines-dry.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\immune\\verify.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\kill-list.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\mutation-preview.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\observability.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\orchestrate-audit.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\planner-ablation.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\prometheus-metrics.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\synthesize-all-in-one.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\verify-contracts.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\verify-unify.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\vscode-smoke.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\w5-finalize.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\wave4-qa.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\scripts\\weekly-report.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\sabou\\odavl_studio\\tools\\gen-api-docs.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
